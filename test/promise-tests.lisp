;;;; 当前存在问题: promise被显示resolve后, resolve后面的逻辑还会执行.
;;;; promise的状态被thread-pool修改之前, 也可能被promise逻辑修改, do-callbacks的:before处有一个简单补丁.
;;;; 若某个promise的值是另一个promise, 相关转发还没测试.
;;;; 由于与thread-pool进行了继承, promise的逻辑使用了很多非局部退出, 逻辑显得有点混乱.

(in-package :cl-trivial-pool-tests)

(defparameter *test-promise-pool* (tpool:make-thread-pool :name "PROMISE-TEST-POOL"))

(defun gen-0 () 0)

(defun make-promise-promise (final-value &optional (pool tpool:*default-thread-pool*) (name "promised-promise"))
  "Return a promise which will be resolved with another promise"
  (let ((fn (lambda (promise)
              (declare (ignore promise))
              (promise:make-promise
               (lambda (p)
                 (declare (ignore p))
                 final-value)))))
    (promise:make-promise fn :pool pool :name name)))

#+sbcl
(defun kill-pool-threads ()
  "Destroy all thread of the pool (thread name starts with 'WORKER-OF-')."
  (dolist (thread (bt:all-threads))
    (when (string= "WORKER-OF-" (subseq (sb-thread:thread-name thread) 0 10))
      (ignore-errors (bt:destroy-thread thread)))))


(defun promise-gen (type)
  "valid `type':
:simple, no resolve invoked, no rejecte invoked, no error signaled, degenerated to a normal work-item.
:simpke-err, no resolve invoked, no rejecte invoked, error signaled, will be rejected automatically.
:explicit-resolve, resolved by invoking resolve.
:reject-err, rejected by calling resolve with an error.
:reject-non-err, rejected by calling resolve with non-error data.
:return-promise, the returned value of this promise is another promise of type :simple, will be forwarded.
:return-err-promise, the returned value of this promise is another promise of type :simple-err, will be forwarded.
:empty, return an empty promise, can be used to test attach.
"
  (ecase type
    (:simple (promise:make-promise (lambda (promise)
                                     (declare (ignore promise)) (+ 1 2 3))
                                   :pool *test-promise-pool* :name "simple-promise"))
    (:simple-err (promise:make-promise (lambda (promise)
                                         (declare (ignore promise))
                                         (let* ((x (gen-0))
                                                (y (/ 1 x)))
                                           (format t "This cannot be reached, or there must be a bug!~%")
                                           y))
                                       :pool *test-promise-pool* :name "simple-error-promise"))
    (:explicit-resolve (promise:make-promise (lambda (promise)
                                               (let ((result (+ 1 2 3)))
                                                 (promise:resolve promise result)
                                                 ;; the following line will be printed now, is will be an enhancement.
                                                 (promise:signal-promise-resolving result)
                                                 (format t "This should not be reached, or there must be a bug!~%")
                                                 result))
                                             :pool *test-promise-pool* :name "explicit-resolve"))
    (:reject-err (promise:make-promise (lambda (promise)
                                         (promise:reject promise (promise:make-promise-error 123 "xx"))
                                         (format t "This cannot be reached, or there must be a bug!~%"))
                                       :pool *test-promise-pool* :name "explicit-reject-promise-err"))
    (:reject-non-err (promise:make-promise (lambda (promise)
                                             (promise:reject promise 123)
                                             (format t "This cannot be reached, or there must be a bug!~%"))
                                           :pool *test-promise-pool* :name "reject-with-ordinary-data"))
    (:return-promise (promise:make-promise (lambda (promise)
                                             (declare (ignore promise))
                                             (promise-gen :simple))))
    (:return-err-promise (promise:make-promise (lambda (promise)
                                                 (declare (ignore promise))
                                                 (promise-gen :simple-err))))
    (:empty (promise:make-empty-promise *test-promise-pool* "empty-promise"))))


;;; -------

(define-test make-promise-condition :parent promise
  (let* ((reason "some-reason")
         (data 123456)
         (condition (promise:make-promise-condition data))
         (warning   (promise:make-promise-warning data reason))
         (err       (promise:make-promise-error data reason))
         (resolving (promise:make-promise-resolve-condition data)))
    (of-type promise:promise-condition condition)
    (of-type promise:promise-warning   warning)
    (of-type promise:promise-error     err)
    (of-type promise:promise-resolve-condition resolving)
    ;;(is equal reason (slot-value condition 'promise::reason))
    (is equal data   (slot-value condition 'promise::data))
    (is equal reason (slot-value warning 'promise::reason))
    (is equal data   (slot-value warning 'promise::data))
    (is equal reason (slot-value err 'promise::reason))
    (is equal data   (slot-value err 'promise::data))
    (is equal data   (slot-value resolving 'promise::data))))

(define-test signal-promise-condition :parent promise
  (fail (promise:signal-promise-error 123 "xxx"))
  (finish (promise:signal-promise-warning 123 "xxx"))
  (finish (promise:signal-promise-condition 123))
  (finish (promise:signal-promise-resolving 123)))

(define-test inspect-promise :parent promise
  (finish (promise:inspect-promise (make-instance 'promise:promise))))

(define-test promisep :parent promise
  (let ((promise (make-instance 'promise:promise))
        (work (tpool:make-work-item)))
    #+sbcl(is-values (promise:promisep promise) (eq t) (eq t))
    #-sbcl(is eql t (promise:promisep promise))

    #+sbcl(is-values (promise:promisep work) (eq nil) (eq t))
    #-sbcl(is eql nil (promise:promisep work))

    #+sbcl(is-values (tpool:work-item-p promise) (eq t) (eq t))
    #-sbcl(is eql t (tpool:work-item-p work))

    #+sbcl(is-values (tpool:work-item-p work) (eq t) (eq t))
    #-sbcl(is eql t (tpool:work-item-p work))))

(define-test make-empty-promise :parent promise
  (true (promise:promisep (promise:make-empty-promise))))

(define-test make-promise :parent promise
  (let* ((pool (tpool:make-thread-pool))
         ;; simple-promise degenerates to a normal work-item, so it will neither be resolved nor finished.
         (simple-promise (promise:make-promise (lambda (promise) (declare (ignore promise)) (+ 1 2 3)) :pool pool))
         ;; simple-err-promise degenerates to a normal work-item, but the error will be handled and rejected with that.
         (simple-err-promise (promise:make-promise (lambda (promise)
                                                     (declare (ignore promise))
                                                     (let* ((x (gen-0))
                                                            (y (/ 1 x)))
                                                       (format t "This cannot be reached, or there must be a bug!~%")
                                                       y))
                                                   :pool pool))
         ;; explicit resolve invoking
         (resolvable-promise (promise:make-promise (lambda (promise)
                                                     (let ((result (+ 1 2 3)))
                                                       (promise:resolve promise result)
                                                       (promise:signal-promise-resolving result)
                                                       (format t "This should not be reached, or there must be a bug!~%")
                                                       result))
                                                   :pool pool))
         ;; error signaled by promise:signal-promise-error, this is also a degenerated normal work-item
         (rejectable-promise-1 (promise:make-promise (lambda (promise)
                                                       (declare (ignore promise))
                                                       (promise:signal-promise-error 123 "test error promise")
                                                       (format t "This cannot be reached, or there must be a bug!~%"))
                                                     :pool pool))
         ;; explicit reject invoking, reject with an promise-error
         (rejectable-promise-2 (promise:make-promise (lambda (promise)
                                                       (promise:reject promise (promise:make-promise-error 123 "xx"))
                                                       (format t "This cannot be reached, or there must be a bug!~%"))
                                                     :pool pool))
         ;; explicit reject invoking, reject with a normal error
         (rejectable-promise-3 (promise:make-promise (lambda (promise)
                                                       (promise:reject promise (make-instance 'error))
                                                       (format t "This cannot be reached, or there must be a bug!~%"))
                                                     :pool pool))
         ;; explicit reject invoking, reject with an ordinary data
         (rejectable-promise-4 (promise:make-promise (lambda (promise)
                                                       (promise:reject promise 123)
                                                       (format t "This cannot be reached, or there must be a bug!~%"))
                                                     :pool pool)))
    (finish (tpool:add-work simple-promise))
    (finish (tpool:add-work simple-err-promise))
    (finish (tpool:add-work resolvable-promise))
    (finish (tpool:add-work rejectable-promise-1))
    (finish (tpool:add-work rejectable-promise-2))
    (finish (tpool:add-work rejectable-promise-3))
    (finish (tpool:add-work rejectable-promise-4))
    (sleep 0.0001)
    ;; degenerated promise
    (is-values (tpool:get-result simple-promise) (equal (list 6)) (eq t))
    (is eq :finished (tpool:get-status simple-promise))
    (is eq nil (promise:promise-finished-p simple-promise)) ; will not be finished a normal work-item
    (is eq nil (promise:promise-resolved-p simple-promise)) ; will not be resolved either
    (is eq nil (promise:promise-rejected-p simple-promise))
    (is eq nil (promise:promise-errored-p  simple-promise))
    (is eq nil (promise:promise-error-obj  simple-promise))
    ;; degenerated promise with error signaled
    (is-values (tpool:get-result simple-err-promise) (eq nil) (eq nil))
    (of-type error (car (tpool:work-item-result simple-err-promise)))
    (is eq :errored (tpool:get-status simple-err-promise))
    (is eq nil (promise:promise-finished-p simple-err-promise))
    (is eq nil (promise:promise-resolved-p simple-err-promise))
    (is eq t   (promise:promise-rejected-p simple-err-promise))
    (is eq t   (promise:promise-errored-p  simple-err-promise))
    (of-type error (promise:promise-error-obj simple-err-promise))
    ;; resolvable promise
    ;; ----------------- have bugs now --------------------
    (is-values (tpool:get-result resolvable-promise) (equal (list 6)) (eq t))
    (is eq :finished (tpool:get-status resolvable-promise))
    (is eq t   (promise:promise-finished-p resolvable-promise)) ; finished and resolved
    (is eq t   (promise:promise-resolved-p resolvable-promise))
    (is eq nil (promise:promise-rejected-p resolvable-promise))
    (is eq nil (promise:promise-errored-p  resolvable-promise))
    (is eq nil (promise:promise-error-obj  resolvable-promise))
    ;; rejectable promise, error signaled with promise:signal-promise-error, also a degenerated normal work-item
    (is-values (tpool:get-result rejectable-promise-1) (eq nil) (eq nil))
    (of-type error (car (tpool:work-item-result rejectable-promise-1)))
    (is eq :errored (tpool:get-status rejectable-promise-1))
    (is eq nil (promise:promise-finished-p rejectable-promise-1))
    (is eq nil (promise:promise-resolved-p rejectable-promise-1))
    (is eq t   (promise:promise-rejected-p rejectable-promise-1))
    (is eq t   (promise:promise-errored-p  rejectable-promise-1))
    (of-type error (promise:promise-error-obj rejectable-promise-1))
    ;; explicit reject invoking, reject with an promise-error
    (is-values (tpool:get-result rejectable-promise-2) (eq nil) (eq nil))
    (of-type error (car (tpool:work-item-result rejectable-promise-2)))
    (is eq :errored (tpool:get-status rejectable-promise-2))
    (is eq nil (promise:promise-finished-p rejectable-promise-2))
    (is eq nil (promise:promise-resolved-p rejectable-promise-2))
    (is eq t   (promise:promise-rejected-p rejectable-promise-2))
    (is eq t   (promise:promise-errored-p  rejectable-promise-2))
    (of-type error (promise:promise-error-obj rejectable-promise-2))
    ;; explicit reject invoking, reject with a normal error
    (is-values (tpool:get-result rejectable-promise-3) (eq nil) (eq nil))
    (of-type error (car (tpool:work-item-result rejectable-promise-3)))
    (is eq :errored (tpool:get-status rejectable-promise-3))
    (is eq nil (promise:promise-finished-p rejectable-promise-3))
    (is eq nil (promise:promise-resolved-p rejectable-promise-3))
    (is eq t   (promise:promise-rejected-p rejectable-promise-3))
    (is eq t   (promise:promise-errored-p  rejectable-promise-3))
    (of-type error (promise:promise-error-obj rejectable-promise-3))
    ;; explicit reject invoking, reject with an ordinary data
    (is-values (tpool:get-result rejectable-promise-4) (eq nil) (eq nil))
    (of-type error (car (tpool:work-item-result rejectable-promise-4)))
    (is eq :errored (tpool:get-status rejectable-promise-4))
    (is eq nil (promise:promise-finished-p rejectable-promise-4))
    (is eq nil (promise:promise-resolved-p rejectable-promise-4))
    (is eq t   (promise:promise-rejected-p rejectable-promise-4))
    (is eq t   (promise:promise-errored-p  rejectable-promise-4))
    (of-type error (promise:promise-error-obj rejectable-promise-4))
    ))

(define-test with-promise :parent promise
  (let* ((pool (tpool:make-thread-pool))
         ;; simple-promise degenerates to a normal work-item, so it will neither be resolved nor finished.
         (simple-promise (promise:with-promise (promise :pool pool) (+ 1 2 3)))
         ;; degenerated promise, with bindings specified
         (simple-promise-with-bindings (promise:with-promise (promise :bindings '((a 1) (b 2) (c 3)) :pool pool)
                                         (+ a b c)))
         ;; simple-err-promise degenerates to a normal work-item, but the error will be handled and rejected with that.
         (simple-err-promise (promise:with-promise (promise :pool pool :name "simple-err-promise")
                               (let* ((x (gen-0))
                                      (y (/ 1 x)))
                                 (format t "This cannot be reached, or there must be a bug!~%")
                                 y)))
         ;; explicit resolve invoking
         (resolvable-promise (promise:with-promise (promise :pool pool)
                               (let ((result (+ 1 2 3)))
                                 (promise:resolve promise result)
                                 (promise:signal-promise-resolving result)
                                 (format t "This should not be reached, or there must be a bug!~%")
                                 result)))
         ;; error signaled by promise:signal-promise-error, this is also a degenerated normal work-item
         (rejectable-promise-1 (promise:with-promise (promise :pool pool)
                                 (promise:signal-promise-error 123 "test error promise")
                                 (format t "This cannot be reached, or there must be a bug!~%")))
         ;; explicit reject invoking, reject with an promise-error
         (rejectable-promise-2 (promise:with-promise (promise :pool pool)
                                 (promise:reject promise (promise:make-promise-error 123 "xx"))
                                 (format t "This cannot be reached, or there must be a bug!~%")))
         ;; explicit reject invoking, reject with a normal error
         (rejectable-promise-3 (promise:with-promise (promise :pool pool)
                                 (promise:reject promise (make-instance 'error))
                                 (format t "This cannot be reached, or there must be a bug!~%")))
         ;; explicit reject invoking, reject with an ordinary data
         (rejectable-promise-4 (promise:with-promise (promise :pool pool)
                                 (promise:reject promise 123)
                                 (format t "This cannot be reached, or there must be a bug!~%"))))
    (finish (tpool:add-work simple-promise))
    (finish (tpool:add-work simple-promise-with-bindings))
    (finish (tpool:add-work simple-err-promise))
    (finish (tpool:add-work resolvable-promise))
    (finish (tpool:add-work rejectable-promise-1))
    (finish (tpool:add-work rejectable-promise-2))
    (finish (tpool:add-work rejectable-promise-3))
    (finish (tpool:add-work rejectable-promise-4))
    (sleep 0.0001)

    ;; degenerated promise
    (is-values (tpool:get-result simple-promise) (equal (list 6)) (eq t))
    (is eq :finished (tpool:get-status simple-promise))
    (is eq nil (promise:promise-finished-p simple-promise)) ; will not be finished a normal work-item
    (is eq nil (promise:promise-resolved-p simple-promise)) ; will not be resolved either
    (is eq nil (promise:promise-rejected-p simple-promise))
    (is eq nil (promise:promise-errored-p  simple-promise))
    (is eq nil (promise:promise-error-obj  simple-promise))
    ;; degenerated promise with bindings
    (is-values (tpool:get-result simple-promise-with-bindings) (equal (list 6)) (eq t))
    (is eq :finished (tpool:get-status simple-promise-with-bindings))
    (is eq nil (promise:promise-finished-p simple-promise-with-bindings)) ; will not be finished a normal work-item
    (is eq nil (promise:promise-resolved-p simple-promise-with-bindings)) ; will not be resolved either
    (is eq nil (promise:promise-rejected-p simple-promise-with-bindings))
    (is eq nil (promise:promise-errored-p  simple-promise-with-bindings))
    (is eq nil (promise:promise-error-obj  simple-promise-with-bindings))
    ;; degenerated promise with error signaled
    (is-values (tpool:get-result simple-err-promise) (eq nil) (eq nil))
    (of-type error (car (tpool:work-item-result simple-err-promise)))
    (is eq :errored (tpool:get-status simple-err-promise))
    (is eq nil (promise:promise-finished-p simple-err-promise))
    (is eq nil (promise:promise-resolved-p simple-err-promise))
    (is eq t   (promise:promise-rejected-p simple-err-promise))
    (is eq t   (promise:promise-errored-p  simple-err-promise))
    (of-type error (promise:promise-error-obj simple-err-promise))
    ;; resolvable promise
    (is-values (tpool:get-result resolvable-promise) (equal (list 6)) (eq t))
    (is eq :finished (tpool:get-status resolvable-promise))
    (is eq t   (promise:promise-finished-p resolvable-promise)) ; finished and resolved
    (is eq t   (promise:promise-resolved-p resolvable-promise))
    (is eq nil (promise:promise-rejected-p resolvable-promise))
    (is eq nil (promise:promise-errored-p  resolvable-promise))
    (is eq nil (promise:promise-error-obj  resolvable-promise))
    ;; rejectable promise, error signaled with promise:signal-promise-error, also a degenerated normal work-item
    (is-values (tpool:get-result rejectable-promise-1) (eq nil) (eq nil))
    (of-type error (car (tpool:work-item-result rejectable-promise-1)))
    (is eq :errored (tpool:get-status rejectable-promise-1))
    (is eq nil (promise:promise-finished-p rejectable-promise-1))
    (is eq nil (promise:promise-resolved-p rejectable-promise-1))
    (is eq t   (promise:promise-rejected-p rejectable-promise-1))
    (is eq t   (promise:promise-errored-p  rejectable-promise-1))
    (of-type error (promise:promise-error-obj rejectable-promise-1))
    ;; explicit reject invoking, reject with an promise-error
    (is-values (tpool:get-result rejectable-promise-2) (eq nil) (eq nil))
    (of-type error (car (tpool:work-item-result rejectable-promise-2)))
    (is eq :errored (tpool:get-status rejectable-promise-2))
    (is eq nil (promise:promise-finished-p rejectable-promise-2))
    (is eq nil (promise:promise-resolved-p rejectable-promise-2))
    (is eq t   (promise:promise-rejected-p rejectable-promise-2))
    (is eq t   (promise:promise-errored-p  rejectable-promise-2))
    (of-type error (promise:promise-error-obj rejectable-promise-2))
    ;; explicit reject invoking, reject with a normal error
    (is-values (tpool:get-result rejectable-promise-3) (eq nil) (eq nil))
    (of-type error (car (tpool:work-item-result rejectable-promise-3)))
    (is eq :errored (tpool:get-status rejectable-promise-3))
    (is eq nil (promise:promise-finished-p rejectable-promise-3))
    (is eq nil (promise:promise-resolved-p rejectable-promise-3))
    (is eq t   (promise:promise-rejected-p rejectable-promise-3))
    (is eq t   (promise:promise-errored-p  rejectable-promise-3))
    (of-type error (promise:promise-error-obj rejectable-promise-3))
    ;; explicit reject invoking, reject with an ordinary data
    (is-values (tpool:get-result rejectable-promise-4) (eq nil) (eq nil))
    (of-type error (car (tpool:work-item-result rejectable-promise-4)))
    (is eq :errored (tpool:get-status rejectable-promise-4))
    (is eq nil (promise:promise-finished-p rejectable-promise-4))
    (is eq nil (promise:promise-resolved-p rejectable-promise-4))
    (is eq t   (promise:promise-rejected-p rejectable-promise-4))
    (is eq t   (promise:promise-errored-p  rejectable-promise-4))
    (of-type error (promise:promise-error-obj rejectable-promise-4))
    ))

(define-test attach :parent promise
  (let* ((pool (tpool:make-thread-pool))
         (simple-promise (promise:make-promise (lambda (promise)
                                                 (declare (ignore promise)) (+ 1 2 3))
                                               :pool pool :name "simple-promise"))
         ;; simple-err-promise degenerates to a normal work-item, but the error will be handled and rejected with that.
         (simple-err-promise (promise:make-promise (lambda (promise)
                                                     (declare (ignore promise))
                                                     (let* ((x (gen-0))
                                                            (y (/ 1 x)))
                                                       (format t "This cannot be reached, or there must be a bug!~%")
                                                       y))
                                                   :pool pool :name "simple-err-promise"))
         ;; explicit resolve invoking
         (resolvable-promise (promise:make-promise (lambda (promise)
                                                     (let ((result (+ 1 2 3)))
                                                       (promise:resolve promise result)
                                                       (promise:signal-promise-resolving result)
                                                       (format t "This should not be reached, or there must be a bug!~%")
                                                       result))
                                                   :pool pool :name "explicit-resolve"))
         ;; resolvable-promise-1, error signaled by promise:signal-promise-error, this is also a degenerated normal work-item,
         ;;   thus it's not included here
         ;; explicit reject invoking, reject with an promise-error
         (rejectable-promise-2 (promise:make-promise (lambda (promise)
                                                       (promise:reject promise (promise:make-promise-error 123 "xx"))
                                                       (format t "This cannot be reached, or there must be a bug!~%"))
                                                     :pool pool :name "explicit-reject-promise-err"))
         ;; explicit reject invoking, reject with a normal error
         (rejectable-promise-3 (promise:make-promise (lambda (promise)
                                                       (promise:reject promise (make-instance 'error))
                                                       (format t "This cannot be reached, or there must be a bug!~%"))
                                                     :pool pool :name "explicit-reject-normal-err"))
         ;; explicit reject invoking, reject with an ordinary data
         (rejectable-promise-4 (promise:make-promise (lambda (promise)
                                                       (promise:reject promise 123)
                                                       (format t "This cannot be reached, or there must be a bug!~%"))
                                                     :pool pool :name "reject-with-ordinary-data"))
         )
    (let ((this-promise simple-promise)
                   (echo-1 (promise:make-empty-promise))
                   (echo-2 (promise:make-empty-promise))
                   (echo-3 (promise:make-empty-promise))
                   (callback-fn (lambda (p &rest values) (apply #'promise:resolve p values)))
                   (errback-fn (lambda (p err) (promise:reject p err))))
               (finish (promise:attach-echoback this-promise echo-1 callback-fn errback-fn))
               (finish (promise:attach-echoback this-promise echo-2 callback-fn errback-fn))
               (finish (promise:attach-echoback this-promise echo-3 callback-fn errback-fn))
               (tpool:add-work this-promise)
               (sleep 0.0001)
               (is eq :finished (tpool:get-status this-promise))
               (is-values (tpool:get-result this-promise) (equal (list 6)) (eq t))
               (is eq nil (promise:promise-resolved-p this-promise))   ; this degenerated promise did not been resolved,
               (is eq nil (promise:promise-resolved-p echo-1))         ; so did it's echobacks,
               (is eq nil (promise:promise-resolved-p echo-2))         ; this will be an enhancement in the future.
               (is eq nil (promise:promise-resolved-p echo-3))
               (is eq nil (promise:promise-rejected-p this-promise))   ; has not been rejected for the same reason
               (is eq nil (promise:promise-rejected-p echo-1))
               (is eq nil (promise:promise-rejected-p echo-2))
               (is eq nil (promise:promise-rejected-p echo-3))
               ;;(format t "~%~%this-promise: ~d~%" this-promise)
               ;;(format t "~%echo-promise-1: ~d~%" echo-1)
               ;;(format t "~%echo-promise-2: ~d~%" echo-2)
               ;;(format t "~%echo-promise-3: ~d~%~%" echo-3)
      )
    (let ((this-promise simple-err-promise)
          (echo-1 (promise:make-empty-promise))
          (echo-2 (promise:make-empty-promise))
          (echo-3 (promise:make-empty-promise))
          (callback-fn (lambda (p &rest values) (apply #'promise:resolve p values)))
          (errback-fn (lambda (p err) (promise:reject p err))))
      (finish (promise:attach-echoback this-promise echo-1 callback-fn errback-fn))
      (finish (promise:attach-echoback this-promise echo-2 callback-fn errback-fn))
      (finish (promise:attach-echoback this-promise echo-3 callback-fn errback-fn))
      (tpool:add-work this-promise)
      (sleep 0.0001)
      (is eq :errored (tpool:get-status this-promise))
      (is-values (tpool:get-result this-promise) (eql nil) (eq nil))
      (is eq nil (promise:promise-resolved-p this-promise))
      (is eq nil (promise:promise-resolved-p echo-1))
      (is eq nil (promise:promise-resolved-p echo-2))
      (is eq nil (promise:promise-resolved-p echo-3))
      (is eq t   (promise:promise-rejected-p this-promise))
      (is eq t   (promise:promise-rejected-p echo-1))
      (is eq t   (promise:promise-rejected-p echo-2))
      (is eq t   (promise:promise-rejected-p echo-3))
      ;;(format t "~%~%this-promise: ~d~%" this-promise)
      ;;(format t "~%echo-promise-1: ~d~%" echo-1)
      ;;(format t "~%echo-promise-2: ~d~%" echo-2)
      ;;(format t "~%echo-promise-3: ~d~%~%" echo-3)
      )
    (let ((this-promise resolvable-promise)
          (echo-1 (promise:make-empty-promise pool "echo1"))
          (echo-2 (promise:make-empty-promise pool "echo2"))
          (echo-3 (promise:make-empty-promise pool "echo3"))
          (callback-fn (lambda (p &rest values) (apply #'promise:resolve p values)))
          (errback-fn (lambda (p err) (promise:reject p err))))
      (finish (promise:attach-echoback this-promise echo-1 callback-fn errback-fn))
      (finish (promise:attach-echoback this-promise echo-2 callback-fn errback-fn))
      (finish (promise:attach-echoback this-promise echo-3 callback-fn errback-fn))
      (tpool:add-work this-promise)
      (sleep 0.1)
      (is eq :finished (tpool:get-status this-promise))
      (is-values (tpool:get-result this-promise nil) (equal (list 6)) (eq t))
      (is eq t   (promise:promise-resolved-p this-promise))   ; this degenerated promise did not been resolved,
      (is eq t   (promise:promise-resolved-p echo-1))         ; so did it's echobacks,
      (is eq t   (promise:promise-resolved-p echo-2))         ; this will be an enhancement in the future.
      (is eq t   (promise:promise-resolved-p echo-3))
      (is eq nil (promise:promise-rejected-p this-promise))
      (is eq nil (promise:promise-rejected-p echo-1))
      (is eq nil (promise:promise-rejected-p echo-2))
      (is eq nil (promise:promise-rejected-p echo-3))
      ;;(format t "~%~%this-promise: ~d~%" this-promise)
      ;;(format t "~%echo-promise-1: ~d~%" echo-1)
      ;;(format t "~%echo-promise-2: ~d~%" echo-2)
      ;;(format t "~%echo-promise-3: ~d~%~%" echo-3)
      )
    (let ((this-promise rejectable-promise-2)
          (echo-1 (promise:make-empty-promise))
          (echo-2 (promise:make-empty-promise))
          (echo-3 (promise:make-empty-promise))
          (callback-fn (lambda (p &rest values) (apply #'promise:resolve p values)))
          (errback-fn (lambda (p err) (promise:reject p err))))
      (finish (promise:attach-echoback this-promise echo-1 callback-fn errback-fn))
      (finish (promise:attach-echoback this-promise echo-2 callback-fn errback-fn))
      (finish (promise:attach-echoback this-promise echo-3 callback-fn errback-fn))
      (tpool:add-work this-promise)
      (sleep 0.1)
      (is eq :errored (tpool:get-status this-promise))
      (is-values (tpool:get-result this-promise nil) (eq nil) (eq nil))
      (is eq nil (promise:promise-resolved-p this-promise))
      (is eq nil (promise:promise-resolved-p echo-1))
      (is eq nil (promise:promise-resolved-p echo-2))
      (is eq nil (promise:promise-resolved-p echo-3))
      (is eq t   (promise:promise-rejected-p this-promise))
      (is eq t   (promise:promise-rejected-p echo-1))
      (is eq t   (promise:promise-rejected-p echo-2))
      (is eq t   (promise:promise-rejected-p echo-3))
      ;;(format t "~%~%this-promise: ~d~%" this-promise)
      ;;(format t "~%echo-promise-1: ~d~%" echo-1)
      ;;(format t "~%echo-promise-2: ~d~%" echo-2)
      ;;(format t "~%echo-promise-3: ~d~%~%" echo-3)
      )
    (let ((this-promise rejectable-promise-3)
          (echo-1 (promise:make-empty-promise))
          (echo-2 (promise:make-empty-promise))
          (echo-3 (promise:make-empty-promise))
          (callback-fn (lambda (p &rest values) (apply #'promise:resolve p values)))
          (errback-fn (lambda (p err) (promise:reject p err))))
      (finish (promise:attach-echoback this-promise echo-1 callback-fn errback-fn))
      (finish (promise:attach-echoback this-promise echo-2 callback-fn errback-fn))
      (finish (promise:attach-echoback this-promise echo-3 callback-fn errback-fn))
      (tpool:add-work this-promise)
      (sleep 0.1)
      (is eq :errored (tpool:get-status this-promise))
      (is-values (tpool:get-result this-promise nil) (eq nil) (eq nil))
      (is eq nil (promise:promise-resolved-p this-promise))
      (is eq nil (promise:promise-resolved-p echo-1))
      (is eq nil (promise:promise-resolved-p echo-2))
      (is eq nil (promise:promise-resolved-p echo-3))
      (is eq t   (promise:promise-rejected-p this-promise))
      (is eq t   (promise:promise-rejected-p echo-1))
      (is eq t   (promise:promise-rejected-p echo-2))
      (is eq t   (promise:promise-rejected-p echo-3))
      ;;(format t "~%~%this-promise: ~d~%" this-promise)
      ;;(format t "~%echo-promise-1: ~d~%" echo-1)
      ;;(format t "~%echo-promise-2: ~d~%" echo-2)
      ;;(format t "~%echo-promise-3: ~d~%~%" echo-3)
      )
    (let ((this-promise rejectable-promise-4)
          (echo-1 (promise:make-empty-promise))
          (echo-2 (promise:make-empty-promise))
          (echo-3 (promise:make-empty-promise))
          (callback-fn (lambda (p &rest values) (apply #'promise:resolve p values)))
          (errback-fn (lambda (p err) (promise:reject p err))))
      (finish (promise:attach-echoback this-promise echo-1 callback-fn errback-fn))
      (finish (promise:attach-echoback this-promise echo-2 callback-fn errback-fn))
      (finish (promise:attach-echoback this-promise echo-3 callback-fn errback-fn))
      (tpool:add-work this-promise)
      (sleep 0.1)
      (is eq :errored (tpool:get-status this-promise))
      (is-values (tpool:get-result this-promise nil) (eq nil) (eq nil))
      (is eq nil (promise:promise-resolved-p this-promise))
      (is eq nil (promise:promise-resolved-p echo-1))
      (is eq nil (promise:promise-resolved-p echo-2))
      (is eq nil (promise:promise-resolved-p echo-3))
      (is eq t   (promise:promise-rejected-p this-promise))
      (is eq t   (promise:promise-rejected-p echo-1))
      (is eq t   (promise:promise-rejected-p echo-2))
      (is eq t   (promise:promise-rejected-p echo-3))
      ;;(format t "~%~%this-promise: ~d~%" this-promise)
      ;;(format t "~%echo-promise-1: ~d~%" echo-1)
      ;;(format t "~%echo-promise-2: ~d~%" echo-2)
      ;;(format t "~%echo-promise-3: ~d~%~%" echo-3)
      )))
